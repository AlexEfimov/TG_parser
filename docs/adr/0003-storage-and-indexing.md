# ADR 0003 – Хранилище и индексация для базы знаний

## Статус
Accepted

## Контекст

TG_parser формирует `KnowledgeBaseEntry` на основе сообщений Telegram (в MVP — на этапе CLI‑экспорта, TR‑55..TR‑65).  
Нужно выбрать подход к хранению и индексации, который:
- поддерживает поиск по тексту и метаданным;
- масштабируется по объёму данных;
- допускает использование векторного поиска в будущем.

## Решение

- Логическая модель:
  - основная сущность – `KnowledgeBaseEntry` (см. `docs/contracts/knowledge_base_entry.schema.json`);
  - каждое сообщение Telegram порождает 0..N записей в базе знаний (в MVP — как результат CLI‑экспорта).
- MVP / локальный запуск:
  - **SQLite** как базовое хранилище, с разделением на отдельные файлы (см. TR‑17/TR‑42):
    - `ingestion_state.sqlite` — состояние ingestion (источники/статусы/курсоры);
    - `raw_storage.sqlite` — raw‑сообщения (уникальность по `source_ref`);
    - `processing_storage.sqlite` — результаты обработки (`ProcessedDocument`, `TopicCard`, `TopicBundle`).
- Серверный запуск / рост:
  - целевая СУБД — **PostgreSQL** (конкурентный доступ, масштабирование, удобнее для будущего API/интеграций).
- Доступ к данным:
  - **SQLAlchemy 2.x (async)** как единый слой доступа к SQLite/PostgreSQL (миграция без смены контрактов и без переписывания пайплайна).
- Индексация / поиск:
  - в MVP слой **Access / Export** = CLI‑экспорт (TR‑55..TR‑64), отдельный поисковый движок не обязателен;
  - при добавлении поиска: PostgreSQL **FTS** (tsvector) и/или **pgvector** для векторного индекса.

## Последствия

- Чёткий контракт `KnowledgeBaseEntry` позволяет менять конкретную СУБД/движок без переписывания всего пайплайна.
- Появляется возможность подключать несколько индексов (полнотекстовый, векторный) к одной логической модели.

## Ссылки

- Выбранный стек (язык/Telegram/LLM/хранилище): `docs/tech-stack.md`
- Минимальная схема SQLite (MVP): `docs/architecture.md` (раздел “Целевая минимальная схема таблиц (SQLite, MVP)”)


